{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scripts = void 0;\n\nvar react_1 = require(\"react\"); // Previously loading/loaded scripts and their current status\n\n\nexports.scripts = {}; // Check for existing <script> tags with this src. If so, update scripts[src]\n// and return the new status; otherwise, return undefined.\n\nvar checkExisting = function (src) {\n  var existing = document.querySelector(\"script[src=\\\"\" + src + \"\\\"]\");\n\n  if (existing) {\n    // Assume existing <script> tag is already loaded,\n    // and cache that data for future use.\n    return exports.scripts[src] = {\n      loading: false,\n      error: null,\n      scriptEl: existing\n    };\n  }\n\n  return undefined;\n};\n\nfunction useScript(_a) {\n  var src = _a.src,\n      _b = _a.checkForExisting,\n      checkForExisting = _b === void 0 ? false : _b,\n      attributes = __rest(_a, [\"src\", \"checkForExisting\"]); // Check whether some instance of this hook considered this src.\n\n\n  var status = src ? exports.scripts[src] : undefined; // If requested, check for existing <script> tags with this src\n  // (unless we've already loaded the script ourselves).\n\n  if (!status && checkForExisting && src && isBrowser) {\n    status = checkExisting(src);\n  }\n\n  var _c = (0, react_1.useState)(status ? status.loading : Boolean(src)),\n      loading = _c[0],\n      setLoading = _c[1];\n\n  var _d = (0, react_1.useState)(status ? status.error : null),\n      error = _d[0],\n      setError = _d[1];\n\n  (0, react_1.useEffect)(function () {\n    // Nothing to do on server, or if no src specified, or\n    // if loading has already resolved to \"loaded\" or \"error\" state.\n    if (!isBrowser || !src || !loading || error) return; // Check again for existing <script> tags with this src\n    // in case it's changed since mount.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n    status = exports.scripts[src];\n\n    if (!status && checkForExisting) {\n      status = checkExisting(src);\n    } // Determine or create <script> element to listen to.\n\n\n    var scriptEl;\n\n    if (status) {\n      scriptEl = status.scriptEl;\n    } else {\n      scriptEl = document.createElement('script');\n      scriptEl.src = src;\n      Object.keys(attributes).forEach(function (key) {\n        if (scriptEl[key] === undefined) {\n          scriptEl.setAttribute(key, attributes[key]);\n        } else {\n          scriptEl[key] = attributes[key];\n        }\n      });\n      status = exports.scripts[src] = {\n        loading: true,\n        error: null,\n        scriptEl: scriptEl\n      };\n    } // `status` is now guaranteed to be defined: either the old status\n    // from a previous load, or a newly created one.\n\n\n    var handleLoad = function () {\n      if (status) status.loading = false;\n      setLoading(false);\n    };\n\n    var handleError = function (error) {\n      if (status) status.error = error;\n      setError(error);\n    };\n\n    scriptEl.addEventListener('load', handleLoad);\n    scriptEl.addEventListener('error', handleError);\n    document.body.appendChild(scriptEl);\n    return function () {\n      scriptEl.removeEventListener('load', handleLoad);\n      scriptEl.removeEventListener('error', handleError);\n    }; // we need to ignore the attributes as they're a new object per call, so we'd never skip an effect call\n  }, [src]);\n  return [loading, error];\n}\n\nexports.default = useScript;\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';","map":{"version":3,"sources":["../src/use-script.tsx"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scripts = void 0;\nvar react_1 = require(\"react\");\n// Previously loading/loaded scripts and their current status\nexports.scripts = {};\n// Check for existing <script> tags with this src. If so, update scripts[src]\n// and return the new status; otherwise, return undefined.\nvar checkExisting = function (src) {\n    var existing = document.querySelector(\"script[src=\\\"\" + src + \"\\\"]\");\n    if (existing) {\n        // Assume existing <script> tag is already loaded,\n        // and cache that data for future use.\n        return (exports.scripts[src] = {\n            loading: false,\n            error: null,\n            scriptEl: existing,\n        });\n    }\n    return undefined;\n};\nfunction useScript(_a) {\n    var src = _a.src, _b = _a.checkForExisting, checkForExisting = _b === void 0 ? false : _b, attributes = __rest(_a, [\"src\", \"checkForExisting\"]);\n    // Check whether some instance of this hook considered this src.\n    var status = src ? exports.scripts[src] : undefined;\n    // If requested, check for existing <script> tags with this src\n    // (unless we've already loaded the script ourselves).\n    if (!status && checkForExisting && src && isBrowser) {\n        status = checkExisting(src);\n    }\n    var _c = (0, react_1.useState)(status ? status.loading : Boolean(src)), loading = _c[0], setLoading = _c[1];\n    var _d = (0, react_1.useState)(status ? status.error : null), error = _d[0], setError = _d[1];\n    (0, react_1.useEffect)(function () {\n        // Nothing to do on server, or if no src specified, or\n        // if loading has already resolved to \"loaded\" or \"error\" state.\n        if (!isBrowser || !src || !loading || error)\n            return;\n        // Check again for existing <script> tags with this src\n        // in case it's changed since mount.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        status = exports.scripts[src];\n        if (!status && checkForExisting) {\n            status = checkExisting(src);\n        }\n        // Determine or create <script> element to listen to.\n        var scriptEl;\n        if (status) {\n            scriptEl = status.scriptEl;\n        }\n        else {\n            scriptEl = document.createElement('script');\n            scriptEl.src = src;\n            Object.keys(attributes).forEach(function (key) {\n                if (scriptEl[key] === undefined) {\n                    scriptEl.setAttribute(key, attributes[key]);\n                }\n                else {\n                    scriptEl[key] = attributes[key];\n                }\n            });\n            status = exports.scripts[src] = {\n                loading: true,\n                error: null,\n                scriptEl: scriptEl,\n            };\n        }\n        // `status` is now guaranteed to be defined: either the old status\n        // from a previous load, or a newly created one.\n        var handleLoad = function () {\n            if (status)\n                status.loading = false;\n            setLoading(false);\n        };\n        var handleError = function (error) {\n            if (status)\n                status.error = error;\n            setError(error);\n        };\n        scriptEl.addEventListener('load', handleLoad);\n        scriptEl.addEventListener('error', handleError);\n        document.body.appendChild(scriptEl);\n        return function () {\n            scriptEl.removeEventListener('load', handleLoad);\n            scriptEl.removeEventListener('error', handleError);\n        };\n        // we need to ignore the attributes as they're a new object per call, so we'd never skip an effect call\n    }, [src]);\n    return [loading, error];\n}\nexports.default = useScript;\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n"]},"metadata":{},"sourceType":"script"}